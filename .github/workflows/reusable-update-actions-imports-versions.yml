name: reusable update actions imports versions

on:
  workflow_call: {}

jobs:
  presubmit-workflow:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@f095bcc56b7c2baf48f3ac70d6d6782f4f553222
      - uses: mikefarah/yq@bbe305500687a5fe8498d74883c17f0f06431ac4
      - id: actions-per-workflow
        run: |
          # steps
          # 1. get jobs from uses fields
          ACTIONS=$(
            for WORKFLOW in $(find .github/workflows -type f -name '*.yml'); do
              ACTIONS=$(< $WORKFLOW \
                yq e '.jobs.*.steps[].uses as $jobsteps | .jobs.*.uses as $jobuses | $jobsteps | [., $jobuses]' -o json \
                  | jq -rcMs --arg file "$WORKFLOW" '{"actions": . | flatten} | .file = $file')
              [ -z "${ACTIONS}" ] && continue
              echo -e "${ACTIONS}"
            done | jq -sc '.'
          )
          echo "actions=$ACTIONS" >> $GITHUB_OUTPUT
      - name: display actions
        run: |
          echo -e '${{ steps.actions-per-workflow.outputs.actions }}' | yq e -P
      - name: iterate through each file's actions and update them
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          for LINE in $(echo '${{ steps.actions-per-workflow.outputs.actions }}' | jq --arg REPOSITORY '${{ github.repository }}' -rcM '.[] | .file as $file | .actions[] | split("@") | .[0] as $action | $action | split("/") | .[0] as $org | .[1] as $repo | {"file": $file, "action": $action, "org": $org, "repo": $repo} | select(.action | contains($REPOSITORY) == false)'); do
            file="$(echo $LINE | jq -rcM .file)"
            action="$(echo $LINE | jq -rcM .action)"
            org="$(echo $LINE | jq -rcM .org)"
            repo="$(echo $LINE | jq -rcM .repo)"

            echo "$file: $action; $org/$repo"

            default_branch="$(gh api repos/$org/$repo --jq .default_branch)"
            latest_commit_hash="$(gh api repos/$org/$repo/commits/$default_branch --jq '.sha')"
            latest_release_tag_name="$(gh api repos/$org/$repo/releases/latest --jq '.tag_name' 2>/dev/null || echo '')"
            latest_release_commit_hash="$(gh api repos/$org/$repo/git/ref/tags/$latest_release_tag_name --jq .object.sha 2>/dev/null || echo '')"

            commit_hash=
            if [ -n "$latest_release_commit_hash" ] && [ ! "$(echo $latest_release_commit_hash | jq .message)" = "Not Found" ]; then
              commit_hash="$latest_release_commit_hash"
            else
              commit_hash="$latest_commit_hash"
            fi

            printf "$file: $action@$commit_hash"
            if [ -n "$latest_release_tag_name" ]; then
              echo " # $latest_release_tag_name"
            fi
          done
      # 1. get latest release
      #   1a. get tag of release, returning commit hash
      # 2. if no latest release,
      #    determine main branch name and
      #    return latest commit on the $MAIN branch
      # NOTE:
      # when editing, use yq like this to persist a comment, for human readable version info
      # $ THING='a # comment' yq e -n '.a = env(THING)'
      #   a: a # comment
